# -*- coding: utf-8 -*-
"""Python_submision_sec_1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1AxsBvSqhsSyoIlh4h8EvZWsZv_DwwQ79
"""

from typing import List


def reverse_by_n_elements(lst: List[int], n: int):

    result = []

    length = len(lst)

    for i in range(0, length, n):

        group = []

        for j in range(min(n, length - i)):

            group.insert(0, lst[i + j])

        result.extend(group)

    return result

# Example usage
print(reverse_by_n_elements([1, 2, 3, 4, 5, 6, 7, 8], 4))

reverse_by_n_elements([10, 20, 30, 40, 50, 60, 70],4)

def group_by_length(lst):

    length_dict = {}

    for s in lst:

        length = len(s)

        if length not in length_dict:

            length_dict[length] = []

        length_dict[length].append(s)

    return dict(sorted(length_dict.items()))

(group_by_length(["apple", "bat", "car", "elephant", "dog", "bear"]))

from typing import Dict, Any

def flatten_dict(nested_dict: Dict[str, Any], sep: str = '.') -> Dict[str, Any]:

    def flatten(current_dict, parent_key=''):
        items = []

        for key, value in current_dict.items():

            new_key = f"{parent_key}{sep}{key}"

            if isinstance(value, dict):

                items.extend(flatten(value, new_key).items())

            elif isinstance(value, list):


                for i, v in enumerate(value):

                    list_key = f"{new_key}[{i}]"

                    if isinstance(v, dict):


                        items.extend(flatten(v, list_key).items())

                    else:
                        items.append((list_key, v))
            else:
                items.append((new_key, value))

        return dict(items)

    return flatten(nested_dict)


nested_dict = {
    "road": {
        "name": "Highway 1",
        "length": 350,
        "sections": [
            {
                "id": 1,
                "condition": {
                    "pavement": "good",
                    "traffic": "moderate"
                }
            }
        ]
    }
}

flattened_dict = flatten_dict(nested_dict)
print(flattened_dict)

def unique_permutations(nums: List[int]) -> List[List[int]]:

    def backtrack(first: int):

        if first == len(nums):

            result.append(nums[:])

            return
        seen = set()
        for i in range(first, len(nums)):

            if nums[i] not in seen:

                seen.add(nums[i])

                nums[first], nums[i] = nums[i], nums[first]

                backtrack(first + 1)

                nums[first], nums[i] = nums[i], nums[first]

    nums.sort()  # Sort the list to handle duplicates
    result = []
    backtrack(0)
    return result

# Example usage
print(unique_permutations([1, 1, 2]))

import re

def find_all_dates(text: str) -> List[str]:

    date_pattern = r'\b\d{2}-\d{2}-\d{4}\b|\b\d{2}/\d{2}/\d{4}\b|\b\d{4}\.\d{2}\.\d{2}\b'


    matches = re.findall(date_pattern, text)

    return matches

text = "I was born on 23-08-1994, my friend on 08/23/1994, and another one on 1994.08.23."
print(find_all_dates(text))

pip install polyline

# You are given a polyline string, which encodes a series of latitude and longitude coordinates. Polyline encoding is a method to efficiently store latitude and longitude data using fewer bytes. The Python polyline module allows you to decode this string into a list of coordinates.

# Write a function that performs the following operations:

# Decode the polyline string using the polyline module into a list of (latitude, longitude) coordinates.
# Convert these coordinates into a Pandas DataFrame with the following columns:
# latitude: Latitude of the coordinate.
# longitude: Longitude of the coordinate.
# distance: The distance (in meters) between the current row's coordinate and the previous row's one. The first row will have a distance of 0 since there is no previous point.
# Calculate the distance using the Haversine formula for points in successive rows.


import pandas as pd
import polyline
from math import radians, cos, sin, sqrt, atan2

def haversine(lat1, lon1, lat2, lon2):

    # Radius of the Earth in meters
    R = 6371000

    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])

    dlat = lat2 - lat1
    dlon = lon2 - lon1
    a = sin(dlat / 2)**2 + cos(lat1) * cos(lat2) * sin(dlon / 2)**2
    c = 2 * atan2(sqrt(a), sqrt(1 - a))
    distance = R * c

    return distance

def polyline_to_dataframe(polyline_str: str) -> pd.DataFrame:


    coordinates = polyline.decode(polyline_str)

    df = pd.DataFrame(coordinates, columns=['latitude', 'longitude'])


    df['distance'] = 0.0

    for i in range(1, len(df)):
        lat1, lon1 = df.loc[i - 1, ['latitude', 'longitude']]
        lat2, lon2 = df.loc[i, ['latitude', 'longitude']]
        df.loc[i, 'distance'] = haversine(lat1, lon1, lat2, lon2)

    return df

polyline_str = '}_ilFzyvpOEk@P{Af@}BtAqD'
df = polyline_to_dataframe(polyline_str)
print(df)

#  Matrix Rotation and Transformation
# Write a function that performs the following operations on a square matrix (n x n):

# Rotate the matrix by 90 degrees clockwise.
# After rotation, for each element in the rotated matrix, replace it with the sum of all elements in the same row and column (in the rotated matrix), excluding itself.
# The function should return the transformed matrix.

# Example
# For the input matrix:

# matrix = [[1, 2, 3],[4, 5, 6],[7, 8, 9]]
# Rotate the matrix by 90 degrees clockwise:

# rotated_matrix = [[7, 4, 1],[8, 5, 2],[9, 6, 3]]
# Replace each element with the sum of all elements in the same row and column, excluding itself:

# final_matrix = [[22, 19, 16],[23, 20, 17],[24, 21, 18]]

from typing import List

def rotate_matrix_90_clockwise(matrix: List[List[int]]) -> List[List[int]]:

    n = len(matrix)
    rotated_matrix = [[0] * n for _ in range(n)]

    for i in range(n):
        for j in range(n):
            rotated_matrix[j][n - 1 - i] = matrix[i][j]

    return rotated_matrix

def sum_row_col_exclude_self(rotated_matrix: List[List[int]]) -> List[List[int]]:

    n = len(rotated_matrix)
    final_matrix = [[0] * n for _ in range(n)]

    for i in range(n):
        for j in range(n):

            row_sum = sum(rotated_matrix[i]) - rotated_matrix[i][j]

            col_sum = sum(rotated_matrix[k][j] for k in range(n)) - rotated_matrix[i][j]

            # Assign the sum of row and column (excluding itself) to the result matrix
            final_matrix[i][j] = row_sum + col_sum

    return final_matrix

def rotate_and_transform_matrix(matrix: List[List[int]]) -> List[List[int]]:


    rotated_matrix = rotate_matrix_90_clockwise(matrix)

    final_matrix = sum_row_col_exclude_self(rotated_matrix)

    return final_matrix


matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

result = rotate_and_transform_matrix(matrix)
for row in result:
    print(row)

def time_check(df):

    df['startTime'] = pd.to_datetime(df['startTime'], format='%H:%M:%S').dt.time
    df['endTime'] = pd.to_datetime(df['endTime'], format='%H:%M:%S').dt.time
    grouped = df.groupby(['id', 'id_2'])

    results = pd.Series(dtype=bool)

    for name, group in grouped:
        if (group['startTime'].min() <= pd.to_datetime('00:00:00', format='%H:%M:%S').time() and
            group['endTime'].max() >= pd.to_datetime('23:59:59', format='%H:%M:%S').time() and
            set(group['startDay']).union(set(group['endDay'])) == set(['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'])):
            results[name] = False
        else:
            results[name] = True

    return results

